<h2 id="1-개요">1. 개요</h2>

<h3 id="docker만-사용할-때의-문제점">Docker만 사용할 때의 문제점</h3>

<p>Docker만으로 컨테이너를 운영하면 다음과 같은 문제들이 발생한다:</p>

<table>
  <thead>
    <tr>
      <th>문제</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>스케일링</strong></td>
      <td>트래픽 증가 시 수동으로 컨테이너를 올리고 연결해야 함</td>
    </tr>
    <tr>
      <td><strong>고가용성</strong></td>
      <td>컨테이너가 죽으면 직접 확인하고 다시 살려야 함</td>
    </tr>
    <tr>
      <td><strong>서비스 디스커버리</strong></td>
      <td>여러 컨테이너가 서로를 어떻게 찾을 것인가?</td>
    </tr>
    <tr>
      <td><strong>로드밸런싱</strong></td>
      <td>트래픽 분산이 없으면 여러 컨테이너를 묶는 의미가 없음</td>
    </tr>
    <tr>
      <td><strong>배포</strong></td>
      <td>무중단 배포를 어떻게 구현할 것인가?</td>
    </tr>
  </tbody>
</table>

<p><strong>Kubernetes는 선언적 구성을 통해 이 문제들을 해결한다.</strong></p>

<hr />

<h2 id="11-kubernetes란">1.1 Kubernetes란?</h2>

<blockquote>
  <p>컨테이너화된 워크로드와 서비스를 관리하기 위한 <strong>오픈소스 오케스트레이션 플랫폼</strong></p>
</blockquote>

<h3 id="명령형-vs-선언적-구성">명령형 vs 선언적 구성</h3>

<p><strong>Docker (명령형)</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">-d</span> <span class="nt">--name</span> web <span class="nt">-p</span> 80:80 nginx
</code></pre></div></div>
<p>→ “web이라는 컨테이너에 nginx 이미지를 올려서 실행하고 포트는 80:80으로 열어”</p>

<p><strong>Kubernetes (선언적)</strong></p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># "나는 nginx 컨테이너가 3개 실행되길 원해"</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">3</span>
</code></pre></div></div>

<hr />

<h2 id="12-docker와의-관계">1.2 Docker와의 관계</h2>

<p>Kubernetes는 <strong>컨테이너 런타임</strong> 위에서 동작하며, Docker는 그 런타임 중 하나다.</p>

<p><img src="docker-k8s.png" alt="" /></p>

<hr />

<h2 id="2-아키텍처-이해">2. 아키텍처 이해</h2>

<h3 id="21-클러스터-구조">2.1 클러스터 구조</h3>

<p>Kubernetes 클러스터는 <strong>Control Plane</strong>과 <strong>Worker Node</strong>로 구성된다.
<img src="archi.png" alt="" /></p>
<h3 id="control-plane-컴포넌트">Control Plane 컴포넌트</h3>

<table>
  <thead>
    <tr>
      <th>컴포넌트</th>
      <th>역할</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>API Server</strong></td>
      <td>모든 통신의 중심점. <code class="language-plaintext highlighter-rouge">kubectl</code> 명령을 받음</td>
    </tr>
    <tr>
      <td><strong>etcd</strong></td>
      <td>클러스터의 모든 상태를 저장하는 분산 key-value 저장소</td>
    </tr>
    <tr>
      <td><strong>Scheduler</strong></td>
      <td>새 Pod를 어느 노드에 배치할지 결정</td>
    </tr>
    <tr>
      <td><strong>Controller Manager</strong></td>
      <td>클러스터 상태를 원하는 대로 유지</td>
    </tr>
  </tbody>
</table>

<h3 id="worker-node-컴포넌트">Worker Node 컴포넌트</h3>

<table>
  <thead>
    <tr>
      <th>컴포넌트</th>
      <th>역할</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>kubelet</strong></td>
      <td>노드의 에이전트. Pod의 생성/삭제를 담당</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="핵심-정리">핵심 정리</h2>

<ol>
  <li><strong>Kubernetes가 필요한 이유</strong>: Docker만으로는 스케일링, 고가용성, 서비스 디스커버리, 로드밸런싱, 무중단 배포가 어렵다</li>
  <li><strong>선언적 구성</strong>: “어떻게”가 아닌 “무엇을” 원하는지 선언하면 Kubernetes가 알아서 처리</li>
  <li><strong>아키텍처</strong>: Control Plane이 전체를 관리하고, Worker Node에서 실제 워크로드가 실행됨</li>
</ol>
