<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>uv로 Python 의존성 관리하기 - 로컬부터 CI/CD까지</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="stylesheet" href="/assets/css/study.css">
    <link rel="stylesheet" href="/assets/css/sidebar.css">
    <link rel="stylesheet" href="/assets/css/header.css">
    <link rel="stylesheet" href="/assets/css/banner.css">
    <link rel="stylesheet" href="/assets/css/sections.css">
    <link rel="stylesheet" href="/assets/css/post.css">
    <link rel="stylesheet" href="/assets/css/categories.css">
    <link rel="stylesheet" href="/assets/css/projects.css">
</head>
<body>
    <div class="container">
        <!-- 사이드바 -->
        <aside class="sidebar">
    <img src="/assets/images/avatar.png" alt="Duri" class="profile-image">
    <div class="profile-info">
        <h2>Duri</h2>
        <p>˗ˏˋ ⋆｡𖦹 ˚ 𓇼 ˚｡⋆ ❀˖°</p>
        <p>옛날에 
 데이터 엔지니어가 있엇슨.. 백엔드 서버도 만들고 인프라도 구축하고 데이터 분석도 했슨.. </p>
    </div>
    
    <div class="contact-links">
        <div class="profile-divider">
    ⠀⠀⠀⠀⠀⠀⢀⡤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡀⠀⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⠀⢀⡏⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⣀⠴⠋⠉⠉⡆⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠈⠉⠉⠙⠓⠚⠁⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⢀⠞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⣄⠀⠀⠀⠀
    ⠀⠀⠀⠀⡞⠀⠀⠀⠀⠀⠶⠀⠀⠀⠀⠀⠀⠦⠀⠀⠀⠀⠀⠸⡆⠀⠀⠀
    ⢠⣤⣶⣾⣧⣤⣤⣀⡀⠀⠀⠀⠀⠈⠀⠀⠀⢀⡤⠴⠶⠤⢤⡀⣧⣀⣀⠀
    ⠻⠶⣾⠁⠀⠀⠀⠀⠙⣆⠀⠀⠀⠀⠀⠀⣰⠋⠀⠀⠀⠀⠀⢹⣿⣭⣽⠇
    ⠀⠀⠙⠤⠴⢤⡤⠤⠤⠋⠉⠉⠉⠉⠉⠉⠉⠳⠖⠦⠤⠶⠦⠞⠁⠀⠀⠀
        </div>
        
        <a href="https://github.com/duri-wip" class="contact-link" target="_blank">
            <i class="fab fa-github"></i>
            <span>GitHub</span>
        </a>
        
        
        <a href="mailto:8s.eow.ooc@gmail.com" class="contact-link">
            <i class="fas fa-envelope"></i>
            <span>Email</span>
        </a>
        
    </div>
    
</aside>
        
        <!-- 메인 콘텐츠 -->
        <main class="main-content">
            <!-- 헤더 -->
            <header class="header">
    <nav>
        <ul class="nav-menu">
            <li class="nav-item">
                <a href="/">home</a>
            </li>
            <li class="nav-item">
                <a href="/categories">category</a>
            </li>
            <li class="nav-item">
                <a href="/study">study</a>
            </li>
            <li class="nav-item">
                <a href="/projects">project</a>
            </li>
        </ul>
    </nav>
</header>
            
            <!-- 콘텐츠 영역 -->
            <div class="content">
                <article class="post">
    <header class="post-header">
        <h1 class="post-title">uv로 Python 의존성 관리하기 - 로컬부터 CI/CD까지</h1>
        <div class="post-meta">
            <time class="post-date">2026년 02월 06일</time>
            
            <div class="post-categories">
                
                    
                    <span class="category-tag">Development</span>
                    
                
                    
                
                
                <span class="subcategory-tag">devops-infra</span>
                
            </div>
            
            
            <div class="post-tags">
                
                <span class="tag">#python</span>
                
                <span class="tag">#uv</span>
                
                <span class="tag">#docker</span>
                
                <span class="tag">#ci-cd</span>
                
                <span class="tag">#dependency-management</span>
                
            </div>
            
        </div>
    </header>

    <div class="post-content">
        <h2 id="의존성-관리가-중요한-이유">의존성 관리가 중요한 이유</h2>

<p>“내 컴퓨터에서는 잘 되는데요?!”</p>

<p>하 혈압올라… 의존성 관리의 핵심 원칙은 두가지다.</p>

<ul>
  <li><strong>환경 일관성</strong>: 각각 다른 개발자의 환경에서도 문제 없이 동일한 소프트웨어 환경을 구축할 수 있어야 함</li>
  <li><strong>재현 가능성</strong>: 각 개발자의 로컬 개발 환경의 차이에도 불구하고 동일한 소프트웨어 의존성을 구축해야 함</li>
</ul>

<p>이 원칙이 깨지는 빈번한 이유는 보통 다음과 같다.</p>
<ul>
  <li><strong>버전의 파편화</strong>: 어떤 사람은 Python 3.9를 쓰고 운영 서버는 Python 3.8을 쓰고…</li>
  <li><strong>라이브러리 오염</strong>: 로컬에 설치된 다른 프로젝트의 라이브러리가 현재 프로젝트에 영향을 미침</li>
  <li><strong>OS 종속성</strong>: 윈도우 환경에서 개발했는데 리눅스 서버로 배포하는 경우</li>
</ul>

<p>그래서 동일한 환경을 구축하기 위해 세 가지 계층의 대응이 필요하다.</p>
<ol>
  <li><strong>의존성 고정</strong>: 라이브러리 A의 특정 버전을 써라</li>
  <li><strong>가상 환경</strong>: 해당 프로젝트만을 위한 환경에서 써라</li>
  <li><strong>컨테이너화</strong>: OS 수준에서 환경을 캡슐화하여 개발자의 로컬 = 테스트 서버 = 운영 서버 환경을 구축</li>
</ol>

<h2 id="uv-vs-pip-무엇이-다른가">uv vs pip: 무엇이 다른가?</h2>

<p>uv는 Rust로 작성된 Python 패키지 매니저로, pip 대비 다음과 같은 장점을 가진다.</p>

<h3 id="1-병렬-다운로드--설치">1. 병렬 다운로드 &amp; 설치</h3>
<p>pip는 Global Interpreter Lock(GIL)을 사용하기 때문에 병렬 다운로드와 설치가 불가능하다. uv는 Rust 기반이라 이런 제약이 없다.</p>

<h3 id="2-글로벌-캐시-시스템">2. 글로벌 캐시 시스템</h3>
<p>한번 다운로드하면 영원히 재사용한다. 한 프로젝트에서 설치된 패키지는 다른 프로젝트에서도 캐시로 사용된다. pip는 캐시가 있어도 매번 복사 설치한다.</p>

<h3 id="3-의존성-해결-알고리즘-최적화">3. 의존성 해결 알고리즘 최적화</h3>
<p>pip는 백트래킹으로 의존성을 해결하려고 하는데, uv는 전체 패키지의 제약조건을 한번에 분석해 최적의 버전 조합을 빠르게 계산한다.</p>

<h3 id="4-universal-locking">4. Universal Locking</h3>
<p>모든 플랫폼(OS)과의 호환성을 검토하고 <code class="language-plaintext highlighter-rouge">uv.lock</code>을 업데이트한다.</p>

<h2 id="uv-프로젝트-구조">uv 프로젝트 구조</h2>

<p><code class="language-plaintext highlighter-rouge">uv init</code>을 실행하면 프로젝트가 초기화되고 다음 파일들이 생성된다.</p>

<h3 id="python-version">.python-version</h3>
<p>현재 개발 환경의 파이썬 버전을 명시한다.</p>

<h3 id="pyprojecttoml">pyproject.toml</h3>
<p>개발자가 직접 설치한 의존성 라이브러리들을 관리한다. <code class="language-plaintext highlighter-rouge">uv add library-a</code>로 의존성을 설치하면 이 라이브러리의 버전이 명시된다.</p>

<h3 id="uvlock">uv.lock</h3>
<p><code class="language-plaintext highlighter-rouge">uv add</code>, <code class="language-plaintext highlighter-rouge">uv sync</code>를 실행하면 생성된다. pyproject.toml에 적힌 라이브러리뿐만 아니라, 그 라이브러리가 의존하는 하위 의존성까지 전부 계산하여 특정 버전으로 박제한다.</p>

<ul>
  <li>add는 라이브러리 추가</li>
  <li>sync는 명시되어있는 의존성 설치</li>
</ul>

<h2 id="universal-lock-파일의-비밀">Universal Lock 파일의 비밀</h2>

<p>uv의 락 파일은 OS에 종속되지 않는 유니버설 구조다. 이게 무슨 의미일까?</p>

<p>해당 패키지가 어떤 환경에서 무엇을 필요로 하는지 메타데이터를 정적으로 분석한다. 그리고 각 OS별 바이너리 파일들의 hash를 모두 락 파일에 적어둔다.</p>

<p><code class="language-plaintext highlighter-rouge">uv.lock</code> 파일을 열어보면 이런 정보가 있다.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">dependencies</span> <span class="p">=</span> <span class="p">[</span>
    <span class="p">{</span> <span class="py">name</span> <span class="p">=</span> <span class="s">"some-package"</span><span class="p">,</span> <span class="py">marker</span> <span class="p">=</span> <span class="py">"sys_platform</span> <span class="p">=</span><span class="err">=</span> <span class="s">'win32'" }</span><span class="err">
]</span>
</code></pre></div></div>

<p>어떤 패키지에는 마커가 붙어있고 어떤 것에는 안 붙어있는데, 이는 분기 처리한 흔적이다. 안 붙어있는 패키지는 OS마다 동일한 파이썬 라이브러리이기 때문이고, 플랫폼 종속적인 패키지들만 마커가 붙는다.</p>

<p>또한 <code class="language-plaintext highlighter-rouge">whl</code>, <code class="language-plaintext highlighter-rouge">sdist</code>의 정보는 각 OS별 바이너리 파일의 해시값을 기록해두는 태그다. 이를 통해 어떤 개발 환경에서 개발하더라도 동일한 의존성 파일을 참고할 수 있다.</p>

<h2 id="uv가-빠른-이유-글로벌-캐시-시스템">uv가 빠른 이유: 글로벌 캐시 시스템</h2>

<p>uv의 동작 과정은 다음과 같다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">pyproject.toml</code> 파일을 읽고 <code class="language-plaintext highlighter-rouge">uv.lock</code> 파일을 업데이트</li>
  <li>각 OS별 캐시 경로에서 라이브러리 파일을 찾음</li>
  <li>캐시에 있으면 새로 다운로드하지 않음, 없으면 다운로드하여 글로벌 캐시에 저장</li>
  <li>프로젝트 폴더의 <code class="language-plaintext highlighter-rouge">.venv</code> 폴더에 <strong>심볼릭 링크 또는 하드 링크</strong>를 사용하여 글로벌 캐시와 가상 환경을 연결</li>
</ol>

<p>pip처럼 매번 복사하지 않고 링크만 걸기 때문에 빠르고 디스크 공간도 절약된다.</p>

<h2 id="docker에서-uv-사용하기">Docker에서 uv 사용하기</h2>

<p>로컬에서 개발할 때는 글로벌 캐시를 사용하지만, Docker로 빌드할 때는 어떻게 해야 할까?</p>

<p>Docker 빌드 시에는 글로벌 캐시가 없다. 하지만 <strong>Docker BuildKit 캐시</strong>를 활용하면 uv의 장점을 살릴 수 있다.</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> python:3.10-slim</span>

<span class="c"># 1. uv 설치</span>
<span class="k">COPY</span><span class="s"> --from=ghcr.io/astral-sh/uv:latest /uv /uvx /bin/</span>

<span class="c"># 2. 작업 디렉토리 설정</span>
<span class="k">WORKDIR</span><span class="s"> /app</span>

<span class="c"># 3. 의존성 파일 먼저 복사 (캐시 효율화)</span>
<span class="k">COPY</span><span class="s"> pyproject.toml uv.lock ./</span>

<span class="c"># 4. 도커 캐시 마운트를 활용한 패키지 설치</span>
<span class="k">RUN </span><span class="nt">--mount</span><span class="o">=</span><span class="nb">type</span><span class="o">=</span>cache,target<span class="o">=</span>/root/.cache/uv <span class="se">\
</span>    uv <span class="nb">sync</span> <span class="nt">--frozen</span> <span class="nt">--no-install-project</span>

<span class="c"># 5. 소스 코드 복사</span>
<span class="k">COPY</span><span class="s"> . .</span>

<span class="c"># 6. 가상환경 활성화 상태로 실행</span>
<span class="k">ENV</span><span class="s"> PATH="/app/.venv/bin:$PATH"</span>
<span class="k">CMD</span><span class="s"> ["uvicorn", "main:app", "--host", "0.0.0.0"]</span>
</code></pre></div></div>

<p>여기서 사용되는 Docker 캐시는 Docker 빌드 엔진인 BuildKit이 관리하는 별도의 로컬 캐시 버킷에 저장된다. 이 버킷은 이미지 레이어와 관련 없이 호스트에 남기 때문에, 다른 이미지를 빌드할 때도 글로벌 캐시처럼 사용할 수 있다.</p>

<h2 id="github-actions에서-uv-캐시-활용하기">GitHub Actions에서 uv 캐시 활용하기</h2>

<p>CI/CD 파이프라인에서는 빌드가 끝나면 서버가 통째로 사라지는 경우가 많다. 그래서 캐시를 외부 저장소에 따로 빼두고 가져오는 방식을 사용한다.</p>

<p>Dockerfile은 위와 동일하게 캐시 마운트를 사용하고, workflow yaml 파일은 다음과 같이 구성한다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">jobs</span><span class="pi">:</span>
  <span class="na">build</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v4</span>

      <span class="c1"># BuildKit 빌더 설정 - 캐시 기능 활성화</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Setup docker buildx</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">docker/setup-buildx-action@v3</span>

      <span class="c1"># push 설정을 위한 레지스트리 로그인</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Login to container registry</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">docker/login-action@v3</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">registry</span><span class="pi">:</span> <span class="s">ghcr.io</span>
          <span class="na">username</span><span class="pi">:</span> <span class="s">$</span>
          <span class="na">password</span><span class="pi">:</span> <span class="s">$</span>

      <span class="c1"># Docker 이미지 빌드 + 캐시 설정</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Build and push</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">docker/build-push-action@v5</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">context</span><span class="pi">:</span> <span class="s">.</span>
          <span class="na">push</span><span class="pi">:</span> <span class="kc">true</span>
          <span class="na">tags</span><span class="pi">:</span> <span class="s">ghcr.io/$:latest</span>
          <span class="na">cache-from</span><span class="pi">:</span> <span class="s">type=gha</span>
          <span class="na">cache-to</span><span class="pi">:</span> <span class="s">type=gha,mode=max</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">cache-from: type=gha</code>와 <code class="language-plaintext highlighter-rouge">cache-to: type=gha,mode=max</code> 설정을 통해 GitHub의 레포지토리별로 관리되는 캐시 서버에서 uv 라이브러리 파일을 가져오고, 빌드가 끝나면 새로 추가된 라이브러리를 다시 서버에 업로드한다.</p>

<h2 id="cloud-build-환경에서는">Cloud Build 환경에서는?</h2>

<p>Google Cloud Build와 같은 환경에서는 GitHub Actions처럼 기본 캐시 기능을 제공하지 않는다. 따라서 캐시 파일을 담아둘 <strong>GCS 버킷</strong>을 만들고, 빌드 설정에서 직접 캐시 파일을 업로드/다운로드해야 한다.</p>

    </div>

    <footer class="post-footer">
        <div class="post-nav">
            
            <a class="prev-post" href="/development/k8s-architecture-and-grpc/">
                <span class="nav-label">이전 글</span>
                <span class="nav-title">쿠버네티스 아키텍처와 gRPC</span>
            </a>
            
            
            
        </div>
        
        <div class="back-to-home">
            <a href="/">← 홈으로 돌아가기</a>
        </div>
    </footer>
</article>
            </div>
        </main>
    </div>
</body>
</html>