<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FastAPI 페이징 및 페이지네이션</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="stylesheet" href="/assets/css/study.css">
    <link rel="stylesheet" href="/assets/css/sidebar.css">
    <link rel="stylesheet" href="/assets/css/header.css">
    <link rel="stylesheet" href="/assets/css/banner.css">
    <link rel="stylesheet" href="/assets/css/sections.css">
    <link rel="stylesheet" href="/assets/css/post.css">
    <link rel="stylesheet" href="/assets/css/categories.css">
    <link rel="stylesheet" href="/assets/css/projects.css">
</head>
<body>
    <div class="container">
        <!-- 사이드바 -->
        <aside class="sidebar">
    <img src="/assets/images/avatar.png" alt="Duri" class="profile-image">
    <div class="profile-info">
        <h2>Duri</h2>
        <p>˗ˏˋ ⋆｡𖦹 ˚ 𓇼 ˚｡⋆ ❀˖°</p>
        <p>옛날에 
 데이터 엔지니어가 있엇슨.. 백엔드 서버도 만들고 인프라도 구축하고 데이터 분석도 했슨.. </p>
    </div>
    
    <div class="contact-links">
        <div class="profile-divider">
    ⠀⠀⠀⠀⠀⠀⢀⡤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡀⠀⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⠀⢀⡏⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⣀⠴⠋⠉⠉⡆⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠈⠉⠉⠙⠓⠚⠁⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⢀⠞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⣄⠀⠀⠀⠀
    ⠀⠀⠀⠀⡞⠀⠀⠀⠀⠀⠶⠀⠀⠀⠀⠀⠀⠦⠀⠀⠀⠀⠀⠸⡆⠀⠀⠀
    ⢠⣤⣶⣾⣧⣤⣤⣀⡀⠀⠀⠀⠀⠈⠀⠀⠀⢀⡤⠴⠶⠤⢤⡀⣧⣀⣀⠀
    ⠻⠶⣾⠁⠀⠀⠀⠀⠙⣆⠀⠀⠀⠀⠀⠀⣰⠋⠀⠀⠀⠀⠀⢹⣿⣭⣽⠇
    ⠀⠀⠙⠤⠴⢤⡤⠤⠤⠋⠉⠉⠉⠉⠉⠉⠉⠳⠖⠦⠤⠶⠦⠞⠁⠀⠀⠀
        </div>
        
        <a href="https://github.com/duri-wip" class="contact-link" target="_blank">
            <i class="fab fa-github"></i>
            <span>GitHub</span>
        </a>
        
        
        <a href="mailto:8s.eow.ooc@gmail.com" class="contact-link">
            <i class="fas fa-envelope"></i>
            <span>Email</span>
        </a>
        
    </div>
    
</aside>
        
        <!-- 메인 콘텐츠 -->
        <main class="main-content">
            <!-- 헤더 -->
            <header class="header">
    <nav>
        <ul class="nav-menu">
            <li class="nav-item">
                <a href="/">home</a>
            </li>
            <li class="nav-item">
                <a href="/categories">category</a>
            </li>
            <li class="nav-item">
                <a href="/study">study</a>
            </li>
            <li class="nav-item">
                <a href="/projects">project</a>
            </li>
        </ul>
    </nav>
</header>
            
            <!-- 콘텐츠 영역 -->
            <div class="content">
                <article class="post">
    <header class="post-header">
        <h1 class="post-title">FastAPI 페이징 및 페이지네이션</h1>
        <div class="post-meta">
            <time class="post-date">2025년 08월 17일</time>
            
            <div class="post-categories">
                
                    
                    <span class="category-tag">Development</span>
                    
                
                    
                
                
                <span class="subcategory-tag">backend</span>
                
            </div>
            
            
            <div class="post-tags">
                
                <span class="tag">#backend</span>
                
                <span class="tag">#fastapi</span>
                
                <span class="tag">#pagination</span>
                
                <span class="tag">#data-handling</span>
                
            </div>
            
        </div>
    </header>

    <div class="post-content">
        <h1 id="페이징-페이지네이션">페이징, 페이지네이션</h1>

<p>대량의 데이터를 여러 페이지로 나누어 표시하는 것.
페이징을 적용하면 다음과 같은 개선점이 있다</p>

<ul>
  <li>사용자 경험 개선</li>
  <li>로딩 시간 감소</li>
  <li>서버 리소스 절약</li>
</ul>

<p>페이징을 적용하려면 현재의 페이지거 몇번재 페이지인지, 한 화면에 몇개의 아이템을 보여줄지를 알아야 한다.</p>

<h1 id="파이단틱-유효성-검사">파이단틱 유효성 검사</h1>

<p>컨트롤러가 존재하는 인터페이스 계층의 구현. 내부에서 사용하는 형식으로 외부에서 받은 데이터를 가공하기 + 내부에서 처리한 결과를 가공하여 외부에 보내기
두개만 잘하면 된다.</p>

<h2 id="1-요청-매개변수--본문-검사">1. 요청 매개변수 / 본문 검사</h2>

<ul>
  <li>새로 스키마 정의 언어를 배우지 않고 타입 힌트를 사용할 줄 안다면 새로 배워야하는 부분이 없다.</li>
  <li>ide, lint, mypy에 모두 활용 가능하다</li>
  <li>계층적 모델을 사용 가능하다</li>
  <li>json 스키마로 문서화할 수 있다.</li>
  <li>사용자 정의 데이터 타입을 정의할 수 있고, validator 데코레이터가 달린 모델의 메서드를 이용해 유효성 검사를 확장할 수 있다.</li>
  <li>테스트 커버리지가 100%다.</li>
</ul>

<p>근데 그러면 외부에서 “21”로 들어오는 문자형 타입이 내부에서는 정수형으로 되어잇으면 변환해서 받는건가?? 파이단틱이??</p>

<h2 id="2-응답-모델-정의">2. 응답 모델 정의</h2>

<p>응답에도 유효성 검사를 적용해 데이터 타입을 제한하거나 길이 제한을 검사할 수 있다.
불필요하게 응답에 포함시켜서는 안되는 데이터에 대한 정의를 할 수 있다.</p>

<h1 id="비동기-프로그래밍">비동기 프로그래밍</h1>

<p>fastapi는 파이썬의 asyncio패키기를 기반으로, async/await 문법을 사용해 비동기 코드를 작성할 수 있다.
파이썬에서 동시성을 처리하는 방법</p>

<ol>
  <li>
    <p>멀티스레딩
부모 프로세스의 메모리 콘텍스트를 공유해 여러 스레드를 실행한다.
가장 잘 알려져있고 오래된 동시성 모델이며, 입출력이 많이 수행되거나 사용자 인터페이스 응답성을 유지해야하는 애플리케이션에서 효과적으로 동작한다.
threading 모듈을 사용해 스레드를 생성하고 관리할 수 있다. 각 스레드는 독립적으로 실행되며, 여러작업을 동시에 처리할 수 있다.
그러나 gil(global interpreter lock)으로 인해 cpu를 주로 사용하는 작업에서는 실제로 동시성 향상이 일어나지 않을 수 있다.</p>
  </li>
  <li>
    <p>멀티 프로세싱
여러 작업을 여러 독립된 프로세스에서 실행해 분산된 환경에서 작동하도록 한다.
멀티 스레딩과 달리 공유 메모리 컨텍스트에 의존하지 않는다.
cpu를 많이 사용하는 애플리케이션에 더 적합하다.
멀티 스레딩보다 무거우며 프로세스간 통신을 구현해 프로세스들이 조화롭게 동작하도록 해야한다.</p>
  </li>
  <li>
    <p>비동기 프로그래밍
여러 작업을 단일 애플리케이션 프로세스에서 실행한다. 협력적 작업들은 스레드처럼 동작하지만 작업 전환은 운영체제 커널이 아니라 애플리케이션이 스스로 담당한다.
io가 많은 애플리케이션, 특히 동시다발적인 네트워크 연결을 다루는 프로그램에 적합하다.
그러나 전용 비동기 라이브러리를 사용해야한다는 단점이 있다.</p>
  </li>
</ol>

<blockquote>
  <p>결론
일반적으로 io 바운드 작업에서는 비동기 프로그래밍이 유용하고 cpu 바운드 작업에는 멀티 스레드/ 멀티 프로세싱이 유용하다고 본다.</p>
</blockquote>

<p>! 그렇지만 모든 병렬처리가 효율적이지는 않다</p>

<h1 id="fastapi의-비동기-처리">fastapi의 비동기 처리</h1>

<p>이렇게 만들면 이렇게 동작한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import asyncio
from datetime import datetime
from fastapi import APIRouter

router = APIRouter("/")

async def async_task(num):
    print("task: ", num)
    await asyncio.sleep(1)
    return num

@router.get("")
async def async_exp():
    now = datetime.now()
    results = await asyncio.gather(
        async_task(1), async_task(2), async_task(3)
    )
    print(datetime.now() - now)

    return {"results": results}
</code></pre></div></div>

<ol>
  <li>async.sleep(1)을 통해 비동기 작업이 1초를 기다린다.</li>
  <li>각 작업을 동시에 수행하고 수행한 모든 작업이 끝날때까지 기다린 다음, 그 결과를 모은다</li>
  <li>순서대로 결과를 모은 다음에 동시에 리턴</li>
</ol>

<h1 id="jwt">jwt</h1>

<p>유저의 로그인 정보를 브라우저나 앱과 같은 클라이언트에 저장하고, 로그인 후의 요청에 이 정보를 전달하는 방식을 취할 수 있다.
이 과정에서 클라이언트의 보안 취약점을 보호하기 위해 jwt를 사용한다.</p>

<p>jwt는 두 당사자 사이에 이전될 수 있는 클레임을 나타내는 간결하면서도 안전한 방법이다.
Jwt에 포함되는 클레임은 Json으로 인코딩 돼 json 웹 서명의 페이로드 또는 json 웹 암호화의 일반 텍스트로 사용된다.
클레임을 디지털 방식으로 서명하거나 메시지 인증 코드로 암호화해서 무결성을 보호한다.</p>

<p>동작방식을 확인할 수 있는 사이트 : https://jwt.io</p>

<h2 id="헤더">헤더</h2>

<p>헤더는 일반적으로 Jwt의 유형과 어떤 알고리즘에 의해 인코딩 됏는지를 포함한다.
“typ” : jwt를 처리하는 애플리케이션에게 페이로드가 무엇인지를 알려주는 역할.
“alg” : 토큰을 암호화하는 알고리즘</p>

<h2 id="페이로드">페이로드</h2>

<p>페이로드는 클레임이라 부르는 정보를 포함한다.</p>

<h3 id="클레임">클레임</h3>

<p>IANA JWT 클레임 저장소에 등록된 클레임.</p>

<ul>
  <li>
    <p>iss(발급자)
토큰을 누가 발급했는지를 나타낸다.</p>
  </li>
  <li>
    <p>sub(주제)
일반적으로 주제에 대한 설명을 나타낸다.</p>
  </li>
  <li>
    <p>aud(수신자)
누구에게 토큰이 전달되는가를 나타낸다.</p>
  </li>
  <li>
    <p>exp(만료 시간)
언제 토큰이 만료되는지를 나타낸다.</p>
  </li>
  <li>
    <p>nbf(정의된 시간 이후)
정의된 시간 이후 토큰이 활성화된다. 토큰이 유효해지는 시간 이전에 미리 발급되는 경우 주로 사용한다.</p>
  </li>
  <li>
    <p>iat(토큰 발급 시간)
언제 토큰이 발급됐는지를 나타낸다</p>
  </li>
  <li>
    <p>jti(토큰 식별자)
토큰의 고유 식별자.</p>
  </li>
</ul>

<h3 id="공개와-비공개-클레임">공개와 비공개 클레임</h3>

<p>표준 클레임에 덧붙여 공개되도 무방한 페이로드를 공개 클레임으로 정의한다.
발급자와 사용자간에 사용하기로 약속한 클레임은 비공개 클레임으로 정의한다.</p>

<h2 id="시그니처">시그니처</h2>

<p>토큰이 유효한지를 검증하기 위해 secret을 사용한다. (hs256알고리즘 기준)</p>

    </div>

    <footer class="post-footer">
        <div class="post-nav">
            
            <a class="prev-post" href="/development/fastapi-middleware/">
                <span class="nav-label">이전 글</span>
                <span class="nav-title">FastAPI 미들웨어</span>
            </a>
            
            
            
            <a class="next-post" href="/development/alembic/">
                <span class="nav-label">다음 글</span>
                <span class="nav-title">SQLAlchemy와 Alembic으로 DB 관리하기</span>
            </a>
            
        </div>
        
        <div class="back-to-home">
            <a href="/">← 홈으로 돌아가기</a>
        </div>
    </footer>
</article>
            </div>
        </main>
    </div>
</body>
</html>