<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>쿠버네티스 아키텍처와 gRPC</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="stylesheet" href="/assets/css/study.css">
    <link rel="stylesheet" href="/assets/css/sidebar.css">
    <link rel="stylesheet" href="/assets/css/header.css">
    <link rel="stylesheet" href="/assets/css/banner.css">
    <link rel="stylesheet" href="/assets/css/sections.css">
    <link rel="stylesheet" href="/assets/css/post.css">
    <link rel="stylesheet" href="/assets/css/categories.css">
    <link rel="stylesheet" href="/assets/css/projects.css">
</head>
<body>
    <div class="container">
        <!-- 사이드바 -->
        <aside class="sidebar">
    <img src="/assets/images/avatar.png" alt="Duri" class="profile-image">
    <div class="profile-info">
        <h2>Duri</h2>
        <p>˗ˏˋ ⋆｡𖦹 ˚ 𓇼 ˚｡⋆ ❀˖°</p>
        <p>옛날에 
 데이터 엔지니어가 있엇슨.. 백엔드 서버도 만들고 인프라도 구축하고 데이터 분석도 했슨.. </p>
    </div>
    
    <div class="contact-links">
        <div class="profile-divider">
    ⠀⠀⠀⠀⠀⠀⢀⡤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡀⠀⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⠀⢀⡏⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⣀⠴⠋⠉⠉⡆⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠈⠉⠉⠙⠓⠚⠁⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀
    ⠀⠀⠀⠀⢀⠞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⣄⠀⠀⠀⠀
    ⠀⠀⠀⠀⡞⠀⠀⠀⠀⠀⠶⠀⠀⠀⠀⠀⠀⠦⠀⠀⠀⠀⠀⠸⡆⠀⠀⠀
    ⢠⣤⣶⣾⣧⣤⣤⣀⡀⠀⠀⠀⠀⠈⠀⠀⠀⢀⡤⠴⠶⠤⢤⡀⣧⣀⣀⠀
    ⠻⠶⣾⠁⠀⠀⠀⠀⠙⣆⠀⠀⠀⠀⠀⠀⣰⠋⠀⠀⠀⠀⠀⢹⣿⣭⣽⠇
    ⠀⠀⠙⠤⠴⢤⡤⠤⠤⠋⠉⠉⠉⠉⠉⠉⠉⠳⠖⠦⠤⠶⠦⠞⠁⠀⠀⠀
        </div>
        
        <a href="https://github.com/duri-wip" class="contact-link" target="_blank">
            <i class="fab fa-github"></i>
            <span>GitHub</span>
        </a>
        
        
        <a href="mailto:8s.eow.ooc@gmail.com" class="contact-link">
            <i class="fas fa-envelope"></i>
            <span>Email</span>
        </a>
        
    </div>
    
</aside>
        
        <!-- 메인 콘텐츠 -->
        <main class="main-content">
            <!-- 헤더 -->
            <header class="header">
    <nav>
        <ul class="nav-menu">
            <li class="nav-item">
                <a href="/">home</a>
            </li>
            <li class="nav-item">
                <a href="/categories">category</a>
            </li>
            <li class="nav-item">
                <a href="/study">study</a>
            </li>
            <li class="nav-item">
                <a href="/projects">project</a>
            </li>
        </ul>
    </nav>
</header>
            
            <!-- 콘텐츠 영역 -->
            <div class="content">
                <article class="post">
    <header class="post-header">
        <h1 class="post-title">쿠버네티스 아키텍처와 gRPC</h1>
        <div class="post-meta">
            <time class="post-date">2026년 02월 06일</time>
            
            <div class="post-categories">
                
                    
                    <span class="category-tag">Development</span>
                    
                
                    
                
                
                <span class="subcategory-tag">devops-infra</span>
                
            </div>
            
            
            <div class="post-tags">
                
                <span class="tag">#kubernetes</span>
                
                <span class="tag">#grpc</span>
                
                <span class="tag">#container</span>
                
                <span class="tag">#docker</span>
                
                <span class="tag">#devops</span>
                
                <span class="tag">#cri</span>
                
                <span class="tag">#cni</span>
                
                <span class="tag">#csi</span>
                
            </div>
            
        </div>
    </header>

    <div class="post-content">
        <h2 id="grpc는-어디에-쓰이는-걸까">gRPC는 어디에 쓰이는 걸까?</h2>

<p><a href="/development/restapi-vs-grpc/">이전 포스트</a>에서 gRPC가 내부 통신을 빠르게 해준다는 걸 알아봤다. 그럼 실제로 어디에 쓰이는 걸까? 가장 가까운 예로 쿠버네티스를 찾을 수 있었다.</p>

<p>쿠버네티스의 핵심 구성 요소들은 서로 gRPC로 통신하고, 새로운 컨테이너 런타임이나 네트워크 플러그인을 끼워넣을 수 있는 것도 gRPC 인터페이스 덕분이다.</p>

<h2 id="쿠버네티스-아키텍처">쿠버네티스 아키텍처</h2>

<p>쿠버네티스는 크게 두 파트로 나뉜다. 전체를 관리하는 <strong>컨트롤 플레인</strong>과 실제 컨테이너가 실행되는 <strong>노드</strong>다.</p>

<h3 id="컨트롤-플레인">컨트롤 플레인</h3>

<p>클러스터의 두뇌 역할을 한다. 네 가지 핵심 컴포넌트로 구성된다.</p>

<ul>
  <li><strong>API 서버</strong>: 모든 요청의 관문이다. 외부 요청도, 내부 구성 요소끼리의 통신도 전부 API 서버를 거친다</li>
  <li><strong>etcd</strong>: 클러스터의 메모리다. 모든 상태 정보(설정값, 어떤 노드에 뭐가 떠있는지 등)를 저장하는 key-value 저장소</li>
  <li><strong>스케줄러</strong>: 새로 만든 Pod를 어떤 노드에 배치할지를 결정한다</li>
  <li><strong>컨트롤러 매니저</strong>: 현재 떠 있는 컨테이너가 선언된 상태와 일치하는지를 계속 확인하고, 하나가 죽으면 다시 살려내는 일을 한다</li>
</ul>

<h3 id="노드">노드</h3>

<p>실제 컨테이너들이 실행되는 워커 머신이다. 세 가지 컴포넌트가 있다.</p>

<ul>
  <li><strong>kubelet</strong>: 컨트롤 플레인과 소통하는 에이전트다. 해당 노드에 어떤 컨테이너가 띄워져야 하는지 명령을 받고, 실행하고, 상태를 보고한다</li>
  <li><strong>kube-proxy</strong>: 노드로 들어오는 네트워크 트래픽을 어떤 컨테이너로 보낼지 정리하는 네트워크 규칙을 관리한다. 쉽게 말하면 로드 밸런서 역할이다. 서비스 이름으로 오는 트래픽을 살아있는 Pod에게 나누어준다</li>
  <li><strong>컨테이너 런타임</strong>: 실제로 컨테이너를 구동시키는 실행 엔진이다</li>
</ul>

<h2 id="인터페이스-중심-설계-쿠버네티스가-유연한-이유">인터페이스 중심 설계: 쿠버네티스가 유연한 이유</h2>

<p>쿠버네티스가 유연한 확장이 가능한 이유는 처음부터 <strong>표준 인터페이스만 정해두고 실제 동작은 구현하지 않겠다</strong>는 설계 철학이 있기 때문이다.</p>

<p>쿠버네티스가 정의한 gRPC 인터페이스 규격은 세 가지다.</p>

<ul>
  <li><strong>CRI (Container Runtime Interface)</strong>: “컨테이너 실행” 규격</li>
  <li><strong>CSI (Container Storage Interface)</strong>: “디스크 연결” 규격</li>
  <li><strong>CNI (Container Network Interface)</strong>: “네트워크 설정” 규격</li>
</ul>

<p>이 규격들은 모두 <code class="language-plaintext highlighter-rouge">.proto</code> 파일로 정의되어 있다. 예를 들어, 새로운 컨테이너 엔진을 만들고 싶다면 쿠버네티스가 정의한 <code class="language-plaintext highlighter-rouge">runtime.proto</code>의 명세대로 gRPC 서버를 구현하기만 하면 된다. 이 구조 덕분에 Docker 대신 containerd를 쓰든, Calico 대신 Cilium을 쓰든, 쿠버네티스 코어를 건드릴 필요가 없다.</p>

<h2 id="pod가-생성되기까지-전체-흐름">Pod가 생성되기까지: 전체 흐름</h2>

<p>사용자가 YAML을 선언하고 나서 실제로 컨테이너가 뜨기까지의 과정을 따라가보자.</p>

<h3 id="1단계-인증과-저장">1단계: 인증과 저장</h3>

<p><code class="language-plaintext highlighter-rouge">kubectl</code>은 사용자가 작성한 YAML을 API 서버에 전달한다. API 서버는 인증/인가를 확인하고, 이상이 없으면 YAML 파일 내용을 <strong>etcd에 저장</strong>한다.</p>

<h3 id="2단계-배치-결정">2단계: 배치 결정</h3>

<p>스케줄러는 API 서버를 감시하고 있다가, <strong>노드에 배정되지 않은 Pod</strong>가 생긴 걸 확인한다. 배정되지 않은 Pod란 etcd에 저장된 Pod 정보 중 <code class="language-plaintext highlighter-rouge">nodeName</code> 필드가 비어있는 경우를 의미한다.</p>

<p>그럼 스케줄러는 각 노드의 리소스 상황을 확인하고 가장 적절한 노드를 골라 API 서버에 보고한다. 이때 <strong>필터링</strong>과 <strong>스코어링</strong> 두 단계를 거친다.</p>

<ul>
  <li><strong>필터링</strong>: Pod가 요구하는 CPU/메모리가 충분한가? 특정 노드에만 띄우라는 조건(nodeSelector 등)이 있는가? 등 노드의 사양이 충분한지를 판단하여 후보를 거른다</li>
  <li><strong>스코어링</strong>: 남은 후보 노드들에 점수를 매긴다. 이미지가 이미 다운로드되어 있는지, 리소스 여유가 더 많은지 등을 따져서 가장 점수가 높은 노드를 선택한다</li>
</ul>

<h3 id="3단계-명령-전달">3단계: 명령 전달</h3>

<p>kubelet이 자신의 노드에 할당된 새로운 Pod 정보를 API 서버로부터 전달받는다. kubelet은 미리 생성된 <strong>gRPC Stub</strong>을 이용해 노드의 컨테이너 런타임에 명령을 보낸다. 이때 kubelet과 컨테이너 런타임 사이의 통신은 <strong>CRI 규격</strong>을 통해 구성되어 있다.</p>

<h3 id="4단계-실제-생성">4단계: 실제 생성</h3>

<p>컨테이너 런타임은 명령을 받고 이미지를 pull한 후 컨테이너를 생성한다. 그 다음 두 가지 추가 작업이 진행된다.</p>

<p><strong>네트워크 설정</strong>: 컨테이너에 IP 주소를 할당하기 위해 gRPC 통신으로 <strong>CNI 플러그인</strong>에게 네트워크 설정을 요청한다. CNI 플러그인은 컨테이너 내부에 고유한 IP 주소를 부여하고, 컨테이너끼리 서로 통신할 수 있는 네트워크를 구성하는 역할을 한다.</p>

<p><strong>스토리지 연결</strong>: 영구 저장소가 필요한 경우 gRPC 통신으로 <strong>CSI 플러그인</strong>에게 디스크 연결을 요청한다. CSI 플러그인은 컨테이너가 삭제되어도 데이터가 날아가지 않도록 외부 저장소와 컨테이너를 연결해주는 역할을 한다.</p>

<h3 id="5단계-완료-보고">5단계: 완료 보고</h3>

<p>kubelet이 API 서버에게 생성 완료 사실을 알린다. kubelet은 컨테이너 런타임으로부터 <strong>gRPC 응답</strong>으로 작업 완료 사실을 전달받고, 이후에도 주기적으로 gRPC 폴링을 통해 컨테이너 내부 프로세스의 상태를 실시간으로 체크하여 보고한다.</p>

<p>API 서버는 이 상태를 다시 etcd에 기록하며, 이로써 선언된 상태와 실제 상태가 일치하게 된다.</p>

    </div>

    <footer class="post-footer">
        <div class="post-nav">
            
            <a class="prev-post" href="/development/restapi-vs-grpc/">
                <span class="nav-label">이전 글</span>
                <span class="nav-title">REST API vs gRPC: 마이크로서비스 통...</span>
            </a>
            
            
            
            <a class="next-post" href="/development/uv-python-dependency-management/">
                <span class="nav-label">다음 글</span>
                <span class="nav-title">uv로 Python 의존성 관리하기 - 로컬부터 ...</span>
            </a>
            
        </div>
        
        <div class="back-to-home">
            <a href="/">← 홈으로 돌아가기</a>
        </div>
    </footer>
</article>
            </div>
        </main>
    </div>
</body>
</html>